{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RESPX A utility for mocking out the Python HTTPX library. QuickStart Start by mocking out HTTPX , using respx.mock , and then add desired request patterns to mock your responses. import httpx import respx @respx . mock async def test_something (): request = respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) response = await httpx . post ( \"https://foo.bar/baz/\" ) assert request . called assert response . status_code == 201 Usage The QuickStart section covers the basics. Continue reading in detail on how Mocking HTTPX is done, or head over to the Developer Interface for a complete guide on how to mock your responses. Installation Install with pip: $ pip install respx Requires Python 3.6+ and HTTPX 0.10.1+. See Changelog for older HTTPX compatibility.","title":"Introduction"},{"location":"#respx","text":"A utility for mocking out the Python HTTPX library.","title":"RESPX"},{"location":"#quickstart","text":"Start by mocking out HTTPX , using respx.mock , and then add desired request patterns to mock your responses. import httpx import respx @respx . mock async def test_something (): request = respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) response = await httpx . post ( \"https://foo.bar/baz/\" ) assert request . called assert response . status_code == 201","title":"QuickStart"},{"location":"#usage","text":"The QuickStart section covers the basics. Continue reading in detail on how Mocking HTTPX is done, or head over to the Developer Interface for a complete guide on how to mock your responses.","title":"Usage"},{"location":"#installation","text":"Install with pip: $ pip install respx Requires Python 3.6+ and HTTPX 0.10.1+. See Changelog for older HTTPX compatibility.","title":"Installation"},{"location":"api/","text":"Developer Interface Mocking Responses HTTP Method API For regular and simple use, use the HTTP method shorthands. See Request API for parameters. respx. get ( url=None , status_code=None , content=None , content_type=None , headers=None , pass_through=False , alias=None ) respx. options (...) respx. head (...) respx. post (...) respx. put (...) respx. patch (...) respx. delete (...) Request API For full control, use the core request method. respx. request ( method , url=None , status_code=None , content=None , content_type=None , headers=None , pass_through=False , alias=None ) Adds a request pattern with given mocked response details. Parameters: method - str | callable Request HTTP method, or Request callback , to match. url - (optional) str | pattern Request exact URL, or URL pattern , to match. status_code - (optional) int - default: 200 Response status code to mock. content - (optional) bytes | str | list | dict | callable | exception - default b\"\" Response content to mock. - See Response Content . content_type - (optional) str - default text/plain Response Content-Type header value to mock. headers - (optional) dict Response headers to mock. pass_through - (optional) bool - default False Mark matched request to pass-through to real server, e.g. don't mock . alias - (optional) str Name this request pattern. - See Call Statistics . Matching Requests Exact URL To match and mock a request by an exact URL, pass the url parameter as a string . respx . get ( \"https://foo.bar/\" , status_code = 204 ) URL pattern Instead of matching an exact URL , you can pass a compiled regex to match the request URL. import httpx import re import respx @respx . mock async def test_something (): url_pattern = re . compile ( r \"^https://foo.bar/\\w+/$\" ) respx . get ( url_pattern , content = \"Baz\" ) response = await httpx . get ( \"https://foo.bar/baz/\" ) assert response . text == \"Baz\" Tip Named groups in the regex pattern will be passed as kwargs to the response content callback , if used. Base URL When adding a lot of request patterns sharing the same domain/prefix, you can configure RESPX with a base_url to use as the base when matching URLs. Like url , the base_url can also be passed as a compiled regex , with optional named groups. import httpx import respx @respx . mock ( base_url = \"https://foo.bar\" ) async def test_something (): async with httpx . Client ( base_url = \"https://foo.bar\" ) as client : request = respx . get ( \"/baz/\" , content = \"Baz\" ) response = await client . get ( \"/baz/\" ) assert response . text == \"Baz\" Request callback For full control of what request to match and what response to mock , pass a callback function as the request(method, ...) parameter. The callback's response argument will be pre-populated with any additional response parameters. import httpx import respx def match_and_mock ( request , response ): \"\"\" Return `None` to not match the request. Return the `response` to match and mock this request. Return the `request` for pass-through behaviour. \"\"\" if request . method != \"POST\" : return None if \"X-Auth-Token\" not in request . headers : response . status_code = 401 else : response . content = \"OK\" return response @respx . mock async def test_something (): custom_request = respx . request ( match_and_mock , status_code = 201 ) respx . get ( \"https://foo.bar/baz/\" ) response = await httpx . get ( \"https://foo.bar/baz/\" ) assert response . status_code == 200 assert not custom_request . called response = await httpx . post ( \"https://foo.bar/baz/\" ) assert response . status_code == 401 assert custom_request . called response = await httpx . post ( \"https://foo.bar/baz/\" , headers = { \"X-Auth-Token\" : \"x\" }) assert response . status_code == 201 assert custom_request . call_count == 2 Repeated patterns If you mock several responses with the same request pattern , they will be matched in order, and popped til the last one. import httpx import respx @respx . mock async def test_something (): respx . get ( \"https://foo.bar/baz/123/\" , status_code = 404 ) respx . get ( \"https://foo.bar/baz/123/\" , content = { \"id\" : 123 }) respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) response = await httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . status_code == 404 # First match response = await httpx . post ( \"https://foo.bar/baz/\" ) assert response . status_code == 201 response = await httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . status_code == 200 # Second match assert response . json () == { \"id\" : 123 } Response Content JSON content To mock a response with json content, pass a list or a dict . The Content-Type header will automatically be set to application/json . import httpx import respx @respx . mock async def test_something (): respx . get ( \"https://foo.bar/baz/123/\" , content = { \"id\" : 123 }) response = await httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . json () == { \"id\" : 123 } Content callback If you need dynamic response content, pass a callback function. When used together with a URL pattern , named groups will be passed as kwargs . import httpx import re import respx def some_content ( request , slug = None ): \"\"\" Return bytes, str, list or a dict. \"\"\" return { \"slug\" : slug } @respx . mock async def test_something (): url_pattern = r \"^https://foo.bar/(?P<slug>\\w+)/$\" ) respx . get ( url_pattern , content = some_content ) response = await httpx . get ( \"https://foo.bar/apa/\" ) assert response . json () == { \"slug\" : \"apa\" } Request Error To simulate a failing request, like a connection error , pass an Exception instance. This is useful when you need to test proper HTTPX error handling in your app. import httpx import respx @respx . mock async def test_something (): respx . get ( \"https://foo.bar/\" , content = httpx . ConnectTimeout ()) response = await httpx . get ( \"https://foo.bar/\" ) # Will raise Built-in Assertions RESPX has the following build-in assertion checks: assert_all_mocked Asserts that all captured HTTPX requests are mocked. Defaults to True . assert_all_called Asserts that all mocked request patterns were called. Defaults to True . Configure checks by using the respx.mock decorator / context manager with parentheses. @respx . mock ( assert_all_called = False ) async def test_something ( httpx_mock ): httpx_mock . get ( \"https://some.url/\" ) # OK httpx_mock . get ( \"https://foo.bar/\" ) response = await httpx . get ( \"https://foo.bar/\" ) assert response . status_code == 200 assert httpx_mock . stats . call_count == 1 async with respx . mock ( assert_all_mocked = False ) as httpx_mock : response = await httpx . get ( \"https://foo.bar/\" ) # OK assert response . status_code == 200 assert httpx_mock . stats . call_count == 1 Without Parentheses When using the global scope @respx.mock decorator / context manager, assert_all_called is disabled . Call Statistics The respx API includes a .calls list, containing captured ( request , response ) tuples, and a .stats MagicMock object with all its bells and whistles , i.e. call_count , assert_called etc. Each mocked response request pattern has its own .calls and .stats , along with .called and .call_count stats shortcuts. import httpx import respx @respx . mock async def test_something (): request = respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) await httpx . post ( \"https://foo.bar/baz/\" ) assert request . called assert request . call_count == 1 respx . get ( \"https://foo.bar/\" , alias = \"index\" ) await httpx . get ( \"https://foo.bar/\" ) assert respx . aliases [ \"index\" ] . called assert respx . aliases [ \"index\" ] . call_count == 1 assert respx . stats . call_count == 2 request , response = respx . calls [ - 1 ] assert request . method == \"GET\" assert response . status_code == 200","title":"Developer Interface"},{"location":"api/#developer-interface","text":"","title":"Developer Interface"},{"location":"api/#mocking-responses","text":"","title":"Mocking Responses"},{"location":"api/#http-method-api","text":"For regular and simple use, use the HTTP method shorthands. See Request API for parameters. respx. get ( url=None , status_code=None , content=None , content_type=None , headers=None , pass_through=False , alias=None ) respx. options (...) respx. head (...) respx. post (...) respx. put (...) respx. patch (...) respx. delete (...)","title":"HTTP Method API"},{"location":"api/#request-api","text":"For full control, use the core request method. respx. request ( method , url=None , status_code=None , content=None , content_type=None , headers=None , pass_through=False , alias=None ) Adds a request pattern with given mocked response details. Parameters: method - str | callable Request HTTP method, or Request callback , to match. url - (optional) str | pattern Request exact URL, or URL pattern , to match. status_code - (optional) int - default: 200 Response status code to mock. content - (optional) bytes | str | list | dict | callable | exception - default b\"\" Response content to mock. - See Response Content . content_type - (optional) str - default text/plain Response Content-Type header value to mock. headers - (optional) dict Response headers to mock. pass_through - (optional) bool - default False Mark matched request to pass-through to real server, e.g. don't mock . alias - (optional) str Name this request pattern. - See Call Statistics .","title":"Request API"},{"location":"api/#matching-requests","text":"","title":"Matching Requests"},{"location":"api/#exact-url","text":"To match and mock a request by an exact URL, pass the url parameter as a string . respx . get ( \"https://foo.bar/\" , status_code = 204 )","title":"Exact URL"},{"location":"api/#url-pattern","text":"Instead of matching an exact URL , you can pass a compiled regex to match the request URL. import httpx import re import respx @respx . mock async def test_something (): url_pattern = re . compile ( r \"^https://foo.bar/\\w+/$\" ) respx . get ( url_pattern , content = \"Baz\" ) response = await httpx . get ( \"https://foo.bar/baz/\" ) assert response . text == \"Baz\" Tip Named groups in the regex pattern will be passed as kwargs to the response content callback , if used.","title":"URL pattern"},{"location":"api/#base-url","text":"When adding a lot of request patterns sharing the same domain/prefix, you can configure RESPX with a base_url to use as the base when matching URLs. Like url , the base_url can also be passed as a compiled regex , with optional named groups. import httpx import respx @respx . mock ( base_url = \"https://foo.bar\" ) async def test_something (): async with httpx . Client ( base_url = \"https://foo.bar\" ) as client : request = respx . get ( \"/baz/\" , content = \"Baz\" ) response = await client . get ( \"/baz/\" ) assert response . text == \"Baz\"","title":"Base URL"},{"location":"api/#request-callback","text":"For full control of what request to match and what response to mock , pass a callback function as the request(method, ...) parameter. The callback's response argument will be pre-populated with any additional response parameters. import httpx import respx def match_and_mock ( request , response ): \"\"\" Return `None` to not match the request. Return the `response` to match and mock this request. Return the `request` for pass-through behaviour. \"\"\" if request . method != \"POST\" : return None if \"X-Auth-Token\" not in request . headers : response . status_code = 401 else : response . content = \"OK\" return response @respx . mock async def test_something (): custom_request = respx . request ( match_and_mock , status_code = 201 ) respx . get ( \"https://foo.bar/baz/\" ) response = await httpx . get ( \"https://foo.bar/baz/\" ) assert response . status_code == 200 assert not custom_request . called response = await httpx . post ( \"https://foo.bar/baz/\" ) assert response . status_code == 401 assert custom_request . called response = await httpx . post ( \"https://foo.bar/baz/\" , headers = { \"X-Auth-Token\" : \"x\" }) assert response . status_code == 201 assert custom_request . call_count == 2","title":"Request callback"},{"location":"api/#repeated-patterns","text":"If you mock several responses with the same request pattern , they will be matched in order, and popped til the last one. import httpx import respx @respx . mock async def test_something (): respx . get ( \"https://foo.bar/baz/123/\" , status_code = 404 ) respx . get ( \"https://foo.bar/baz/123/\" , content = { \"id\" : 123 }) respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) response = await httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . status_code == 404 # First match response = await httpx . post ( \"https://foo.bar/baz/\" ) assert response . status_code == 201 response = await httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . status_code == 200 # Second match assert response . json () == { \"id\" : 123 }","title":"Repeated patterns"},{"location":"api/#response-content","text":"","title":"Response Content"},{"location":"api/#json-content","text":"To mock a response with json content, pass a list or a dict . The Content-Type header will automatically be set to application/json . import httpx import respx @respx . mock async def test_something (): respx . get ( \"https://foo.bar/baz/123/\" , content = { \"id\" : 123 }) response = await httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . json () == { \"id\" : 123 }","title":"JSON content"},{"location":"api/#content-callback","text":"If you need dynamic response content, pass a callback function. When used together with a URL pattern , named groups will be passed as kwargs . import httpx import re import respx def some_content ( request , slug = None ): \"\"\" Return bytes, str, list or a dict. \"\"\" return { \"slug\" : slug } @respx . mock async def test_something (): url_pattern = r \"^https://foo.bar/(?P<slug>\\w+)/$\" ) respx . get ( url_pattern , content = some_content ) response = await httpx . get ( \"https://foo.bar/apa/\" ) assert response . json () == { \"slug\" : \"apa\" }","title":"Content callback"},{"location":"api/#request-error","text":"To simulate a failing request, like a connection error , pass an Exception instance. This is useful when you need to test proper HTTPX error handling in your app. import httpx import respx @respx . mock async def test_something (): respx . get ( \"https://foo.bar/\" , content = httpx . ConnectTimeout ()) response = await httpx . get ( \"https://foo.bar/\" ) # Will raise","title":"Request Error"},{"location":"api/#built-in-assertions","text":"RESPX has the following build-in assertion checks: assert_all_mocked Asserts that all captured HTTPX requests are mocked. Defaults to True . assert_all_called Asserts that all mocked request patterns were called. Defaults to True . Configure checks by using the respx.mock decorator / context manager with parentheses. @respx . mock ( assert_all_called = False ) async def test_something ( httpx_mock ): httpx_mock . get ( \"https://some.url/\" ) # OK httpx_mock . get ( \"https://foo.bar/\" ) response = await httpx . get ( \"https://foo.bar/\" ) assert response . status_code == 200 assert httpx_mock . stats . call_count == 1 async with respx . mock ( assert_all_mocked = False ) as httpx_mock : response = await httpx . get ( \"https://foo.bar/\" ) # OK assert response . status_code == 200 assert httpx_mock . stats . call_count == 1 Without Parentheses When using the global scope @respx.mock decorator / context manager, assert_all_called is disabled .","title":"Built-in Assertions"},{"location":"api/#call-statistics","text":"The respx API includes a .calls list, containing captured ( request , response ) tuples, and a .stats MagicMock object with all its bells and whistles , i.e. call_count , assert_called etc. Each mocked response request pattern has its own .calls and .stats , along with .called and .call_count stats shortcuts. import httpx import respx @respx . mock async def test_something (): request = respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) await httpx . post ( \"https://foo.bar/baz/\" ) assert request . called assert request . call_count == 1 respx . get ( \"https://foo.bar/\" , alias = \"index\" ) await httpx . get ( \"https://foo.bar/\" ) assert respx . aliases [ \"index\" ] . called assert respx . aliases [ \"index\" ] . call_count == 1 assert respx . stats . call_count == 2 request , response = respx . calls [ - 1 ] assert request . method == \"GET\" assert response . status_code == 200","title":"Call Statistics"},{"location":"mocking/","text":"Mocking HTTPX To mock out HTTPX , use the respx.mock decorator / context manager. Using the Decorator import httpx import respx @respx . mock async def test_something (): request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\" Using the Context Manager import httpx import respx async with respx . mock : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\" Advanced Usage Use respx.mock without parentheses for global scope, or with parentheses for local scope and configurable checks. For more details on checks, see RESPX Built-in Assertions . NOTE You can also start and stop mocking HTTPX manually, by calling respx.start() and respx.stop() . Sync Support HTTPX is, since version 0.8 , an async only HTTP client. You can still use the respx.mock decorator on regular sync functions to mock out HTTPX and responses.","title":"Mocking HTTPX"},{"location":"mocking/#mocking-httpx","text":"To mock out HTTPX , use the respx.mock decorator / context manager.","title":"Mocking HTTPX"},{"location":"mocking/#using-the-decorator","text":"import httpx import respx @respx . mock async def test_something (): request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\"","title":"Using the Decorator"},{"location":"mocking/#using-the-context-manager","text":"import httpx import respx async with respx . mock : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\"","title":"Using the Context Manager"},{"location":"mocking/#advanced-usage","text":"Use respx.mock without parentheses for global scope, or with parentheses for local scope and configurable checks. For more details on checks, see RESPX Built-in Assertions . NOTE You can also start and stop mocking HTTPX manually, by calling respx.start() and respx.stop() .","title":"Advanced Usage"},{"location":"mocking/#sync-support","text":"HTTPX is, since version 0.8 , an async only HTTP client. You can still use the respx.mock decorator on regular sync functions to mock out HTTPX and responses.","title":"Sync Support"}]}